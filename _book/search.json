[
  {
    "objectID": "01-writing-reports.html#lines-and-lists",
    "href": "01-writing-reports.html#lines-and-lists",
    "title": "1  Writing Reports",
    "section": "Lines and Lists",
    "text": "Lines and Lists\nOn your left in Rstudio (what is called the code source), you have numbers like below that represent lines of text or code:\n1   Some text\n2\n3\n4\n5\nA list in text can be made by first skipping a line, and then starting the next line with numbers followed by a period (.) which is then followed by a space, or by using a hyphen (-) followed by a space:\n1   Some text\n2\n3   1. Start of my list\n4\n5\nLines 1 to 5 will show in your document as:\nSome text\n\nStart of my list\n\n–\nTo create a list within a list, indent twice before using -. Hit tab to indent.\n1   Some text\n2\n3   1. Start of my list\n4           - List within my list\n5\nLines 1 to 5 will show in your document as:\nSome text\n\nStart of my list\n\nList within my list\n\n\n–\nA list is broken if there is an empty line and a subsequent line that is not indented twice.\n1   Some text\n2\n3   1. Start of my list\n4           - List within my list\n5\n6   This line breaks the list\n7           - Some line indented twice in my code source\nLines 1 to 7 will show in your document as:\nSome text\n\nStart of my list\n\nList within my list\n\n\nThis line breaks the list - Some line indented twice in my code source"
  },
  {
    "objectID": "01-writing-reports.html#code",
    "href": "01-writing-reports.html#code",
    "title": "1  Writing Reports",
    "section": "Code",
    "text": "Code\nCode cannot be written on lines like text. For example\n1   some_code\n2   \n3\nwill not work. Code has to be declared in one of two ways.\n\nDeclaring With Single Back-Ticks\nYou can insert code into your document using a single back-tick (the ` symbol) before and after:\n1   Here's `some_code` to be shown.\n2   \n3   \nTo run, R code needs an r after the first back-tick:\n1   Here's `r some_code` to be processed.\n2   \n3   \nFor example, the date can be added to a line of your document using\n1   This report was made on `r Sys.Date()`.\n2\n3\nLines 1 to 3 will show in your document as:\nThis report was made on 2025-01-10.\n–\n\n\n\n\nDeclaring With Multiple Back-Ticks\nYou can insert multiple lines of code into your document using multiple back-ticks before and after:\n10    ```{r}\n11    some_code\n12    some_more_code\n14    ```\nThe ```{r} starts the R code chunk and the ``` ends the chunk.\nThe primary purpose of a code chunk is to contain multiple lines of code. We will get an error when preparing our document if we try to declare with single back-ticks like here:\n10    `r  \n11  \n12    Sys.Date()\n13\n14    Sys.Date()\n15\n16    `\nInstead we must write this as:\n10    ```{r}\n11    Sys.Date()\n12    Sys.Date()\n13    ```\nThe following will be the result of the above chunk in our document:\n\nSys.Date()\n\n[1] \"2025-01-10\"\n\nSys.Date()\n\n[1] \"2025-01-10\"\n\n\nWhen declaring code with chunks (multiple back-ticks), the document will show both the code and the result of the code and this can be customized. When declaring code with single back-ticks, the document will show only the result of the code and this cannot be customized.\nSince the back-ticks take effort to write, there is a shortcut to writing an empty code chunk: command-Shift-I on Mac or ctrl-Shift-I on Windows.\n\n\nSummary\nTo summarize, compared to declaring code with single back-ticks,\n\nChunks can contain multiple lines.\nChunks can show both the code and the result of the code. This is great for showing your work or explaining your code to readers. This flexible property lets you decide whether the chunk shows the code and the result, only one of the two, or neither."
  },
  {
    "objectID": "01-writing-reports.html#errors",
    "href": "01-writing-reports.html#errors",
    "title": "1  Writing Reports",
    "section": "Errors",
    "text": "Errors\nWhen code is not written correctly, errors and probably some frustration will follow. R errors are not known for being friendly; they are not kind enough to tell you what is wrong in a way that is easy to understand. When there is an error, you will see it in red text within the Console, which is a box on the bottom left quarter of RStudio (its default layout). The Console is where the code is processed and the result printed.\nThere are symbols we need to know to understand the Console:\n&gt; means the line of code processed\n+ means a line of code continuing from the last line\n[1] means the first element of the result of the processed code\n[n] means the n'th element of the result of the processed code\n[[1]]\n[1] means the first element in the first container of the result of the processed code\nWhen first learning R, the best way to understand errors is usually not through R’s error messages. The best way is by paying close attention to the code and every little detail: misspelling, capitalization, and punctuation.\nFor this reason we want to practice good strategies of writing code. Writing involves naming our own objects and functions. But before that, we should also name our files using a good strategy. For a quick guide on naming files, click here."
  },
  {
    "objectID": "01-writing-reports.html#links",
    "href": "01-writing-reports.html#links",
    "title": "1  Writing Reports",
    "section": "Links",
    "text": "Links\nTo add a clickable link that sends the user to a website, place the website address within inequality symbols &lt; … &gt;. For example: &lt;http://www2.stat.duke.edu/~rcs46/lectures_2015/01-markdown-git/slides/naming-slides/naming-slides.pdf&gt; gives us http://www2.stat.duke.edu/~rcs46/lectures_2015/01-markdown-git/slides/naming-slides/naming-slides.pdf\nTo make this a hyperlink, that is, a shorter, clickable link, write the clickable text (the text you want to the reader to see) in square brackets and the website address in round brackets like so [text-seen-by-reader](link). For example\n1   [File Naming Presentation by Jenny Bryan](http://www2.stat.duke.edu/~rcs46/lectures_2015/01-markdown-git/slides/naming-slides/naming-slides.pdf)\n2\n3\nLines 1 to 3 will show as:\nFile Naming Presentation by Jenny Bryan"
  },
  {
    "objectID": "01-writing-reports.html#keyboard-shortcuts",
    "href": "01-writing-reports.html#keyboard-shortcuts",
    "title": "1  Writing Reports",
    "section": "Keyboard Shortcuts",
    "text": "Keyboard Shortcuts\nRemember, if you are using Windows, use\n\nctrl instead of command\nalt instead of option\n\nShortcuts:\n\ncommand-Z: Undo (go back)\ncommand-shift-Z: Redo (go forward)\ncommand-Enter: Process line of code where | is blinking (consistently appearing and disappearing)\ncommand-option-C: Process current chunk\noption-shift-arrow_key: Highlight all to the direction of the arrow"
  },
  {
    "objectID": "02-file-naming.html#consistency",
    "href": "02-file-naming.html#consistency",
    "title": "2  File Naming",
    "section": "Consistency",
    "text": "Consistency\nUse _ as a separator, that is, to separate different characteristics of the file. Use - to separate parts within characteristics. For example,\nlesson-1_on-qmd_2022-02-18.qmd\nIf you have related files that you want to systematically process, then be systematic with the order of characteristics. For example,\nlesson-1_on-qmd_2022-02-18.qmd\nlesson-2_on-qmd_2022-02-19.qmd\nlesson-3_on-qmd_2022-02-20.qmd\nlesson-1_on-python_2022-02-20.qmd\nConsider how these files will look when ordered alphabetically in your operating system’s file manager (File Explorer on Window’s or Finder on Mac) if that is important to you. The above files will be ordered like so:\nlesson-1_on-qmd_2022-02-18.qmd\nlesson-1_on-ruby_2022-02-20.qmd\nlesson-2_on-qmd_2022-02-19.qmd\nlesson-3_on-qmd_2022-02-20.qmd\nIf the order of characteristics start with the most general, then the alphabetic ordering will be more appropriate:\non-qmd_lesson-1_2022-02-18.qmd\non-qmd_lesson-2_2022-02-19.qmd\non-qmd_lesson-3_2022-02-20.qmd\non-ruby_lesson-1_2022-02-20.qmd"
  },
  {
    "objectID": "02-file-naming.html#why-consistency-matters",
    "href": "02-file-naming.html#why-consistency-matters",
    "title": "2  File Naming",
    "section": "Why Consistency Matters",
    "text": "Why Consistency Matters\nConsistency helps you visually process the files you see on your file explorer. It also helps when telling your computer how to process the files. We named the files using separators so that numeric information can be represented. That is, the phrase before the first _ is the first characteristic, the phrase before the second _ is the second characteristic and so on.\nTo process the file names in a way that splits these characteristics, we can use a function str_split from an R package called stringr. File names are strings. Strings are character elements that cannot directly be treated numerically (they need to be converted into numeric elements first for that).\nTo use a function from a package, we first install the package by running\n\ninstall.packages(\"stringr\")\n\nDelete this line once you are done, as you will have no need to rerun (re-process) it.\nWe use a colon (the symbol :) twice to use a function from a package. If you write\n\nstringr::\n\nyou will see a drop-down menu of all the functions from stringr. str stands for string. Many function names start with str_. The drop-down menu from writing stringr:: adjusts when you add str_. For every function whose name starts with str_, the general purpose is the processing of strings. Similar to our file names above, the general part of the name comes first, then the _, and then the more specific purpose.\nThere are a few exceptions; some functions in stringr do not start with str_. But most start with str_ because str_ makes it clear what the function will process. This is important as we can avoid the need to write out stringr::. We avoid this by loading the package: making the function names in the package available. To load the package, run the following\n\nlibrary(stringr)\n\nNow when we only write str_, we still get a drop-down menu."
  },
  {
    "objectID": "02-file-naming.html#finding-and-organizing-our-files",
    "href": "02-file-naming.html#finding-and-organizing-our-files",
    "title": "2  File Naming",
    "section": "Finding and Organizing Our Files",
    "text": "Finding and Organizing Our Files\nTo use an str_ function, we need some strings. Let’s get our consistent file names into R. We will use a function called file.choose. This function causes a pop-up that allows you to interactively search your computer files. If you are using Windows, this pop-up may unfortunately pop-up behind RStudio. You will need to Alt-Tab to find the pop-up. Once you see the pop-up, find the folder with your files and double click on (any) one of the files. The function will print the file path (the computer’s representation of where the file exists). Below we assign the file path to the object file_path.\n\nfile_path &lt;- file.choose()\n\nWe will now use a function path_dir from the package fs. path_dir will get the path of the directory from the file path. We will assign the result to the object directory_path.\n\nlibrary(fs)\ndirectory_path &lt;- path_dir(file_path)\n\nTo get a list of .csv files in this directory, we will use a list.files function. This function has what are called two arguments. The first is the path to the folder that contains our files. The second is the pattern that is unique to the files we want.\n\nfiles &lt;- list.files(directory_path, pattern = \"csv\")\nfiles\n\n[1] \"gapminder_afganistan_2022-02-21.csv\" \n[2] \"gapminder_afghanistan_2022-02-21.csv\"\n[3] \"gapminder_canada_2022-02-21.csv\"     \n\n\nNow we use str_split which will split our strings. For example,\n\nstr_split(files, \"_\")\n\n[[1]]\n[1] \"gapminder\"      \"afganistan\"     \"2022-02-21.csv\"\n\n[[2]]\n[1] \"gapminder\"      \"afghanistan\"    \"2022-02-21.csv\"\n\n[[3]]\n[1] \"gapminder\"      \"canada\"         \"2022-02-21.csv\"\n\n\nThis result is what is called a list. A list can contain anything. The [[1]] and [[2]] represent the first and second element of the list. The [1] indicates that the element to its very right is the first element.\nTo also separate the file type (.qmd) at the end, preceded by the period, we can adjust our function to separate by _ as well as ..\n\nstr_split(files, \"_.\")\n\n[[1]]\n[1] \"gapminder\"     \"fganistan\"     \"022-02-21.csv\"\n\n[[2]]\n[1] \"gapminder\"     \"fghanistan\"    \"022-02-21.csv\"\n\n[[3]]\n[1] \"gapminder\"     \"anada\"         \"022-02-21.csv\"\n\n\nWhat happened? This is not what we want, and it is because . is a special (i.e. meta) character. Special characters mean more to R than the literal symbol itself. The special character . represents any character. Hence we told str_split to use _. as a separator which meant that _A was used as the first separator, and _2 as the second separator. We need to use different special characters to overcome this challenge: [ and ]. These square brackets can be used to surround the distinct characters that str_split will use as separators: [_.] will tell str_split to use either a _ or a literal . as the separator.\n\nstr_split(files, \"[_.]\")\n\n[[1]]\n[1] \"gapminder\"  \"afganistan\" \"2022-02-21\" \"csv\"       \n\n[[2]]\n[1] \"gapminder\"   \"afghanistan\" \"2022-02-21\"  \"csv\"        \n\n[[3]]\n[1] \"gapminder\"  \"canada\"     \"2022-02-21\" \"csv\"       \n\n\nWe can have a cleaner result using str_split_fixed. It is called “fixed” as we can fix the number of splits or pieces. We will split our strings into 4 pieces.\n\nstr_split_fixed(files, \"[_.]\", 4)\n\n     [,1]        [,2]          [,3]         [,4] \n[1,] \"gapminder\" \"afganistan\"  \"2022-02-21\" \"csv\"\n[2,] \"gapminder\" \"afghanistan\" \"2022-02-21\" \"csv\"\n[3,] \"gapminder\" \"canada\"      \"2022-02-21\" \"csv\"\n\n\nThis result is what is called a matrix. Let’s assign it to the object m.\n\nm &lt;- str_split_fixed(files, \"[_.]\", 4)\n\nNow we can see the matrix just by processing\n\nm\n\n     [,1]        [,2]          [,3]         [,4] \n[1,] \"gapminder\" \"afganistan\"  \"2022-02-21\" \"csv\"\n[2,] \"gapminder\" \"afghanistan\" \"2022-02-21\" \"csv\"\n[3,] \"gapminder\" \"canada\"      \"2022-02-21\" \"csv\"\n\n\nLet’s add informative names to the columns of the matrix. To do this, we use a function called colnames. This function will be placed on the left of &lt;- as it is a replacement function. We replace the null (i.e. undefined) column names of our matrix with our list of characteristics.\n\ncolnames(m) &lt;- c(\"source\", \"country\", \"date\", \"file_type\")\nm\n\n     source      country       date         file_type\n[1,] \"gapminder\" \"afganistan\"  \"2022-02-21\" \"csv\"    \n[2,] \"gapminder\" \"afghanistan\" \"2022-02-21\" \"csv\"    \n[3,] \"gapminder\" \"canada\"      \"2022-02-21\" \"csv\"    \n\n\nLet’s create an object named df with a function called as_tibble from the package tibble. What is a tibble? It is an R word for table. Remember to install tibble before running\n\nlibrary(tibble)\ndf &lt;- as_tibble(m)\ndf\n\n# A tibble: 3 × 4\n  source    country     date       file_type\n  &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    \n1 gapminder afganistan  2022-02-21 csv      \n2 gapminder afghanistan 2022-02-21 csv      \n3 gapminder canada      2022-02-21 csv      \n\n\n\n\n\n\n\n\nWe now need the file path for each of our files. To list the files in our directory, use the function dir_ls. Assign the result to object file_path.\n\nfile_paths &lt;- dir_ls(directory_path)\n\nWe will now change our tibble so that there is a new column called file_path that contains our file_paths. To do this, we will use a function from the package dplyr (pronounced “data plier”). The function we will use is named after another word for change: mutate. This function has two arguments. The first is the tibble. The second is the name of the new column, an equal sign, and the values we want in that column.\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndf &lt;- mutate(df, file_path = file_paths)\n\n\nReading in Data\nWe can read in the data related to each file with the help of the file_path column. Not only that, we can read in the data so that it is organized inside our tibble. In each row of our tibble, we will add each file’s data hidden in a little box or “nest”. These nests will go under a column called data.\nTo change our tibble so that there is a new column, we will again use mutate. The first argument is the tibble, just like above. The second is the name of the new column (data), an equal sign, and the values we want in that column.\nSince the values in this column will be data sets, we need to put these data sets in containers. Where we see \"csv\" 3 times under file_type in our tibble, we will see \"&lt;S3: spec_tbl_df&gt;\" 3 times under data. The &lt; and &gt; mean container. The S3: spec_tbl_df means data frame (another word for data set).\nWe need to use a special function inside mutate when creating our data column so that the values of the data column are containers. This special function is called map from the package purrr. purrr is pronounced like a cat’s purr (the low vibrating sound of happiness) and it refers to purposeful programming with R.\nThe result of map will always be containers. The number of containers will always be the same as the length of the first argument to map. The second argument of map is the function that will be applied to the first argument. To create the data column, the first argument will be the file_path, and the second argument will be a custom read function.\nThe read function below read_csv_c uses a function called read_csv from the package readr. read_csv reads .csv files and determines what kind of columns are in the data (e.g. numeric or character). We will decide the kind of columns ourselves, so we need to prevent the function from doing so. col_types is the argument inside of read_csv with a .default. We need to set the .default to be \"c\". \"c\" stands for character. Character is a safe default as it is the original format of the .csv data.\n\nlibrary(readr)\n\nread_csv_c &lt;- function(csv_file_path) read_csv(csv_file_path, col_types = c(.default = \"c\"))\n\nNow we use our new function to read in our data.\n\ndf &lt;- mutate(df, data = map(file_path, read_csv_c))\ndf\n\n# A tibble: 3 × 6\n  source    country     date       file_type file_path                data      \n  &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     &lt;fs::path&gt;               &lt;named li&gt;\n1 gapminder afganistan  2022-02-21 csv       …ganistan_2022-02-21.csv &lt;spc_tbl_&gt;\n2 gapminder afghanistan 2022-02-21 csv       …hanistan_2022-02-21.csv &lt;spc_tbl_&gt;\n3 gapminder canada      2022-02-21 csv       …r_canada_2022-02-21.csv &lt;spc_tbl_&gt;\n\n\nWe no longer need the file_path column so we will select it to be removed by using the select function.\n\ndf &lt;- select(df, - file_path)"
  },
  {
    "objectID": "03-opening-the-data.html#checking-data",
    "href": "03-opening-the-data.html#checking-data",
    "title": "3  Opening the Data",
    "section": "Checking Data",
    "text": "Checking Data\nThe simplest way to start evaluating data is to check that the values under each column meet expectations. Since we created the first 4 columns using our file names, we can be sure that these 4 columns are clean.\nFor the next column, continent, we expect values to be continents, capitalized, and spelled correctly. Instead of reading each line with our eyes, we can read each line with our computers. Or a combination of the two. That is exactly how we will start. We will check all unique (i.e. distinct) values under the continent column using distinct. It produces a tibble with only the distinct rows for the column(s) you choose.\n\ndistinct(df, continent)\n\n# A tibble: 2 × 1\n  continent\n  &lt;chr&gt;    \n1 Asia     \n2 Americas \n\n\nThese unique values are perfect. Which means every value is perfect, as these unique values represent them. But what if they were not capitalized, for example? That is in fact the case with our country column: the values are not capitalized because the values came from our file-naming, and it is good practice not to capitalize when file-naming. To capitalize the values in a column, you can use a function called str_to_title.\n\nstr_to_title(df$country)\n\n [1] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\"\n [6] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\"\n[11] \"Afghanistan\" \"Afghanistan\" \"Canada\"      \"Canada\"      \"Canada\"     \n[16] \"Canada\"      \"Canada\"      \"Canada\"      \"Canada\"      \"Canada\"     \n[21] \"Canada\"      \"Canada\"      \"Canada\"      \"Canada\"     \n\ndf\n\n# A tibble: 24 × 9\n   source    country     date  file_type continent year  lifeExp pop   gdpPercap\n   &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    \n 1 gapminder afghanistan 2022… csv       Asia      1952  28.801  8425… 779.4453…\n 2 gapminder afghanistan 2022… csv       Asia      1957  30.332  9240… 820.8530…\n 3 gapminder afghanistan 2022… csv       Asia      1962  31.997  1026… 853.10071\n 4 gapminder afghanistan 2022… csv       Asia      1967  34.02   1153… 836.1971…\n 5 gapminder afghanistan 2022… csv       Asia      1972  36.088  1307… 739.9811…\n 6 gapminder afghanistan 2022… csv       Asia      1977  38.438  1488… 786.11336\n 7 gapminder afghanistan 2022… csv       Asia      1982  39.854  1288… 978.0114…\n 8 gapminder afghanistan 2022… csv       Asia      1987  40.822  1386… 852.3959…\n 9 gapminder afghanistan 2022… csv       Asia      1992  41.674  1631… 649.3413…\n10 gapminder afghanistan 2022… csv       Asia      1997  41.763  2222… 635.3413…\n# ℹ 14 more rows"
  },
  {
    "objectID": "03-opening-the-data.html#finding-functions",
    "href": "03-opening-the-data.html#finding-functions",
    "title": "3  Opening the Data",
    "section": "Finding Functions",
    "text": "Finding Functions\nHow would you know which function to use if I did not tell you?\n\nLarge-Language-Models\nNo explanation needed.\n\n\nGoogle\nGoogle is a great search engine that most R programmers use when learning the R language. If we search “r capitalize first letter” we see, on 2025-01-10, the following paragraph as the first result:\n\nConvert First letter of every word to Uppercase in R Programming – str_to_title() Function. str_to_title() Function in R Language is used to convert the first letter of every word of a string to Uppercase and the rest of the letters are converted to lower case.\n\nThe trick is to, within Google, always write r before a question or the desired command, like how to capitalize first letter or simply capitalize first letter.\nThis is a simple example. Most of the time it can be difficult to write in English what you want. This will come with time and practice. At first you may find that the Google search results have nothing to do with what you need. That is a sign to re-word your search, or, if you’ve already re-worded your search, it may be a sign that there is no dedicated function for what you need, or that a different approach is needed. It’s rare that there will be no dedicated function so long as your goal is simple. You may find that it is effective to break down what you’re doing into simple steps, and then search for how to do those steps, as opposed to Googling something long and complicated, involving many steps.\n\n\nStack Overflow\nSpeaking of breaking down something complicated so that a search engine like Google can understand it, this is also necessary for others to understand it. For learning R, allowing others to understand your challenge or need is valuable as the R community is not only willing, but also quickly able to help. R users mainly help each other through Stack Overflow. It is a website that easily allows users to ask or answer questions with code, have their code formatted (look nice), and receive feedback.\nThe main draw of Stack Overflow is that the person asking the question has one main responsibility, and that is to produce what is called a minimally reproducible example: an example that can be used (reproduced) by someone else seeing the question, and that does not have unnecessary detail irrelevant to the question (minimal).\nDescribe example\nEXAMPLE HERE\nKnowing how to make an example is the majority of the work involved in asking a question on Stack Overflow.\n\nCreating Minimally Reproducible Examples\nIf your question involves data frames, you need to learn how to build a data frame before asking your question on Stack Overflow. To build a data frame, you can use the tibble function from package tibble.\nIf you have 2 numeric columns, like in\n\n\n# A tibble: 12 × 2\n   year  lifeExp\n   &lt;chr&gt; &lt;chr&gt;  \n 1 1952  28.801 \n 2 1957  30.332 \n 3 1962  31.997 \n 4 1967  34.02  \n 5 1972  36.088 \n 6 1977  38.438 \n 7 1952  68.75  \n 8 1957  69.96  \n 9 1962  71.3   \n10 1967  72.13  \n11 1972  72.88  \n12 1977  74.21  \n\n\nthen the first part of your minimal example might look this:\n\ntibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\n\n# A tibble: 4 × 2\n      x     y\n  &lt;dbl&gt; &lt;dbl&gt;\n1     1     3\n2     2     4\n3     1     2\n4     2     2\n\n\nAnd if what you’re trying to achieve is\n\n\n# A tibble: 6 × 2\n  year  mean_lifeExp\n  &lt;chr&gt;        &lt;dbl&gt;\n1 1952          48.8\n2 1957          50.1\n3 1962          51.6\n4 1967          53.1\n5 1972          54.5\n6 1977          56.3\n\n\nthen the second part of your minimal example might look like this:\n\ntibble(x = c(1, 2), mean_y = c(2.5, 2))\n\n# A tibble: 2 × 2\n      x mean_y\n  &lt;dbl&gt;  &lt;dbl&gt;\n1     1    2.5\n2     2    2  \n\n\nTo summarize, your entire question on Stack Overflow could look like this:\nHow can I transform the first tibble into the second tibble with a function?\nlibrary(tibble)\ntibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\ntibble(x = c(1, 2), mean_y = c(2.5, 2))\nTo make your question even better, you can format your code by using the reprex function from the reprex package. The curly brackets are needed to tell reprex that you have multiple lines of code.\n\nlibrary(reprex)\nreprex(\n  {\n    library(tibble)\n    tibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\n    tibble(x = c(1, 2), mean_y = c(2.5, 2))\n  }\n)\n\nFinally your question looks friendly:\nHow can I transform the first tibble into the second tibble with a function?\n\nlibrary(tibble)\ntibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3\n#&gt; 2     2     4\n#&gt; 3     1     2\n#&gt; 4     2     2\ntibble(x = c(1, 2), mean_y = c(2.5, 2))\n#&gt; # A tibble: 2 × 2\n#&gt;       x mean_y\n#&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1     1    2.5\n#&gt; 2     2    2"
  },
  {
    "objectID": "03-opening-the-data.html#finding-function-documentation-for-understanding-functions",
    "href": "03-opening-the-data.html#finding-function-documentation-for-understanding-functions",
    "title": "3  Opening the Data",
    "section": "Finding Function Documentation for Understanding Functions",
    "text": "Finding Function Documentation for Understanding Functions\nOnce you’ve found a function (or usually, a set of functions) recommended to you by Google’s search results, or by R users on Stack Overflow, it would be wise to understand how the function(s) work; specifically, the inputs and outputs.\nBoth Google and Stack Overflow can be overwhelming. Google gives a variety of websites. Which do you choose? A question on Stack Overflow can receive multiple answers, with each using different approaches and functions. Again, which do you choose?\nLet’s start with Google then.\n\nGoogle\nRemember, after searching “r capitalize first letter” we saw the following paragraph as the first result:\n\nConvert First letter of every word to Uppercase in R Programming – str_to_title() Function. str_to_title() Function in R Language is used to convert the first letter of every word of a string to Uppercase and the rest of the letters are converted to lower case.\n\nThis paragraph is from a website called GeeksforGeeks\nI would not recommend to use this website. That is, after searching “r capitalize first letter” and seeing the the above paragraph, I would not recommend to visit the website to understand the function. And for multiple reasons.\n\nYou are not familiar with the format of the website.\nYou will find yourself on multiple websites when you need to discover and learn about multiple functions.\nYou will then have to navigate the formats of these websites.\nMany things can get in the way of reading the instructions, like pop-ups to sign up for the website’s email list, advertisements for completely unrelated products (everything you need to learn R is FREE), and recommended articles to distract you.\n\nIt is more effective to use a single, standardized resource when learning about functions. Thankfully, R has a few.\nAfter reading the above paragraph and learning that the function we need may be str_to_title(), we can now Google search “r str_to_title” instead of “r capitalize first letter”. Again, Google shows multiple websites, but we are looking for one that is standardized. tidyverse.org is one of those websites, so we click the result that has “tidyverse.org” in the website address This brings us to this page: https://stringr.tidyverse.org/reference/case.html\nAs standard, there are multiple sections to the webpage describing a function: Usage, Arguments and Examples. Usage shows the format of the inputs to the function. Any input with an = beside it has a default value. A default value usually indicates that most users will not need to change the value.\nThe Usage str_to_title(string, locale = \"en\") tells us that\n\nstring should be an object containing some string(s) or a string itself. It has no default value; we must provide one.\nlocale has the default value \"en\".\n\nThe Arguments tell us more about the inputs in case the Usage is not enough. When first learning R, Arguments can be overwhelming; you might quickly find yourself not understanding the words contained therein, and having to continuously look up definitions (or more function documentation) in order to understand.\n\n\nStack Overflow\nAnother way of understanding functions is to be presented with answers from others on Stack Overflow. These answers don’t need to be answers to the questions you have posted on Stack Overflow; they can be answers to questions posted by others.\nFor example, here is a question dated from 2019: https://stackoverflow.com/questions/58996293/transforming-a-dataframe-by-multiplying-a-columns-elements-by-the-names-of-th\nThere are three separate answers that have up votes (positive feedback represented by the digit on the top left of an answer): 1 using the data.table package; 1 using base R (R without packages); and 1 using tidyr.\nNotice how the answer using tidyr is far more simple; it is one line of code. This word tidy keeps popping up, and for good reason: the functions in this package and more broadly in the tidyverse (the tidy universe) are designed to make coding short and simple.\nIt is possible to add comments to the answers on Stack Overflow, with further questions about the functions if there is something you don’t understand. Fortunately the tidyverse functions are well documented because of their standardized webpages, and because of multiple, free books on using them for specific tasks.\n\n\nBooks\nThere are many books describing tidyverse functions. Finding a good book is a strong alternative to using Google or Stack Overflow toward understanding functions. A book can hold your hand throughout each step and provide a narrative. It can also be designed toward a specific task, just as this one is designed toward getting you started as quickly and comfortably as possible."
  },
  {
    "objectID": "04-understanding-tidyverse.html#mutate",
    "href": "04-understanding-tidyverse.html#mutate",
    "title": "4  Understanding Tidyverse Functions",
    "section": "mutate",
    "text": "mutate\nWe already went over mutate. This function is used to both create new columns and overwrite existing columns.\nWe can overwrite an existing column like so:\n\ndf &lt;- mutate(df, year = as.numeric(year))\n\nHaving a numeric year is useful if, for example, we want to filter the data by years between 1960 and 1980. This is done with filter.\n\ndf &lt;- filter(df, 1960 &lt; year & year &lt; 1980)"
  },
  {
    "objectID": "04-understanding-tidyverse.html#pumping-with",
    "href": "04-understanding-tidyverse.html#pumping-with",
    "title": "4  Understanding Tidyverse Functions",
    "section": "Pumping with %>%",
    "text": "Pumping with %&gt;%\nNotice that the examples in the function documentation for mutate (https://dplyr.tidyverse.org/reference/mutate.html) and filter use the symbol %&gt;%.\nThe %&gt;% is very simple. It simply sends the left side to the right side. The other property to remember is that %&gt;% holds mathematical priority before brackets and exponents. So if you know BEDMASS, then you also know BE%&gt;%DMASS.\n\nsqrt(5) \n\n[1] 2.236068\n\n\nis the same as\n\n5 %&gt;% sqrt\n\n[1] 2.236068\n\n\nBut\n\n5 * 5 %&gt;% sqrt\n\n[1] 11.18034\n\n\nis not the same as\n\n(5 * 5) %&gt;% sqrt\n\n[1] 5\n\n\nFor a more relevant example,\n\ndf &lt;- mutate(df, year = as.numeric(year))\n\nis the same as\n\ndf &lt;- df %&gt;% mutate(year = as.numeric(year))\n\nwhich is the same as\n\ndf &lt;- df %&gt;% mutate(year = year %&gt;% as.numeric)"
  },
  {
    "objectID": "04-understanding-tidyverse.html#grouping-with-group",
    "href": "04-understanding-tidyverse.html#grouping-with-group",
    "title": "4  Understanding Tidyverse Functions",
    "section": "Grouping with group",
    "text": "Grouping with group\nNotice that the examples in the function documentation for filter (https://dplyr.tidyverse.org/reference/filter.html) use the function group_by.\ngroup_by groups the data for the function(s) that follow group_by.\nLet us create a simple example to demonstrate… (To be continued)"
  },
  {
    "objectID": "05-strings.html#patterns-and-regular-expressions-regexes",
    "href": "05-strings.html#patterns-and-regular-expressions-regexes",
    "title": "5  Strings",
    "section": "Patterns and Regular Expressions (regexes)",
    "text": "Patterns and Regular Expressions (regexes)\nShort for regular expressions, regex (pronounced reg-ex) is a language for describing patterns in strings.\nLike any language, regex will appear foreign and difficult to understand without constantly looking up definitions for symbols. A good dictionary is the regex cheat sheet; search for “Regular Expressions” in https://www.rstudio.com/resources/cheatsheets/. The important definitions are in the left and bottom boxes.\nWhy learn this language? When do you need a language for describing patterns in strings?"
  },
  {
    "objectID": "05-strings.html#motivation",
    "href": "05-strings.html#motivation",
    "title": "5  Strings",
    "section": "Motivation",
    "text": "Motivation\nThe first definition under heading “Character Classes” is\n[[:digit:]] or \\\\d  Digits; [0-9]\nThis tells us that to represent digits in patterns, we can write \"[[:digit:]]\" or \"\\\\d\".\nWhen do we need patterns? Let’s say we want to make sure each row in the date column of our df has exactly 8 digits: 4 for the year, 2 for the month and 2 for the day. We cannot write the 8 digits directly, we need to represent them abstractly; that is the responsibility of patterns.\nThe pattern for digits is \"[[:digit:]]\" or \"\\\\d\". Now we need a pattern for “8 times”. We also cannot simply write 8, as we want to avoid representing the character 8. We now look for the abstract pattern representing “times”: or, in other words, “occurences”. On the bottom right, this pattern will be under the grey heading “Quantifiers”.\nThe 4th defintion is\n{n}  Matches exactly n times\nThis tells us that to match 8 times, we can write \"{8}\".\nCombining what we learned about digits, we now write a pattern for digits 8 times: \"\\\\d{8}\".\nBefore using this pattern, let us try to understand each symbol. The \\\\ are needed to make sure that the pattern is not for the character “d” itself. Similarly, the { and } are needed to make sure that the pattern is not for the number “8” itself.\nIf we try to use our pattern to filter for dates with 8 digits, we get the following\n\ndf |&gt; filter(date |&gt; str_detect(\"\\\\d{8}\"))\n\n# A tibble: 0 × 5\n# ℹ 5 variables: source &lt;chr&gt;, country &lt;chr&gt;, date &lt;chr&gt;, file_type &lt;chr&gt;,\n#   data &lt;named list&gt;\n\n\n0 rows in our date column have digits exactly 8 times. How can that be?\nLooking back at our date column, what do we see?\n\ndf\n\n# A tibble: 3 × 5\n  source    country     date       file_type data               \n  &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     &lt;named list&gt;       \n1 gapminder afganistan  2022-02-21 csv       &lt;spc_tbl_ [0 × 5]&gt; \n2 gapminder afghanistan 2022-02-21 csv       &lt;spc_tbl_ [12 × 5]&gt;\n3 gapminder canada      2022-02-21 csv       &lt;spc_tbl_ [12 × 5]&gt;\n\n\ndate has 4 digits, followed by a hyphen, followed by 2 digits, followed by a hyphen, followed by 2 digits. Our pattern simply represents 8 digits, one after the other with nothing in between.\nIf we alter our pattern to \"\\\\d{4}-\\\\d{2}-\\\\d{2}\", we get the expected result:\n\ndf |&gt; filter(date |&gt; str_detect(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\"))\n\n# A tibble: 3 × 5\n  source    country     date       file_type data               \n  &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     &lt;named list&gt;       \n1 gapminder afganistan  2022-02-21 csv       &lt;spc_tbl_ [0 × 5]&gt; \n2 gapminder afghanistan 2022-02-21 csv       &lt;spc_tbl_ [12 × 5]&gt;\n3 gapminder canada      2022-02-21 csv       &lt;spc_tbl_ [12 × 5]&gt;\n\n\nNow we not only checked that each row in date has 8 digits, but that theses digits are separated by hyphens in a XXXX-XX-XX format.\nWe still have not confirmed that the date column is in YYYY-MM-DD format (year-month-day format). This is unfortunately impossible for some cases. We cannot determine whether 02-04 is February 4nd or April 2nd unless we know whether the date was entered as MM-DD or DD-MM. Fortunately we can check cases where the day is greater than the 12th. We do so by checking whether the month in YYYY-MM-DD is between 01 and 12.\nTo do so we will adjust our pattern slightly so that month becomes a reference. To make a reference in a pattern, we surround the part we want to reference with round brackets: ( and ).\n\npattern &lt;- \"\\\\d{4}-(\\\\d{2})-\\\\d{2}\"\n\nTo extract the reference, we must refer to it by number. We need to use a number, as it is possible to have more than one reference group. Again we use \\\\ to make sure the pattern is not for the number “1” itself.\n\nreplacement &lt;- \"\\\\1\"\n\nWe now use our pattern and replacement in the function str_replace:\n\nmonth &lt;- \"2022-13-01\" |&gt; str_replace(pattern, replacement)\nmonth\n\n[1] \"13\"\n\n\nWe can treat this as numeric.\n\nmonth |&gt; as.numeric()\n\n[1] 13\n\n\nAnd then check whether it is above 12.\n\nmonth |&gt; as.numeric() &gt; 12\n\n[1] TRUE\n\n\nTo do this for every row of our data frame, we will create a month column, treat it as numeric, and filter by values greater than 12:\n\ndf &lt;- df |&gt; \n  mutate(month = date |&gt; str_replace(\"\\\\d{4}-(\\\\d{2})-\\\\d{2}\", \"\\\\1\") |&gt; as.numeric())\n\ndf |&gt; filter(month &gt; 12)\n\n# A tibble: 0 × 6\n# ℹ 6 variables: source &lt;chr&gt;, country &lt;chr&gt;, date &lt;chr&gt;, file_type &lt;chr&gt;,\n#   data &lt;named list&gt;, month &lt;dbl&gt;\n\n\nThere are no rows where month is greater than 12. Notice how the mutate is on a separate line after the pump |&gt;. This is so that the mutate can fit on one line as opposed to the less easily readable version below.\n\ndf &lt;- df |&gt; mutate(month = date |&gt; str_replace(\"\\\\d{4}-(\\\\d{2})-\\\\d{2}\", \"\\\\1\") |&gt; as.numeric())"
  },
  {
    "objectID": "05-strings.html#understanding-representations",
    "href": "05-strings.html#understanding-representations",
    "title": "5  Strings",
    "section": "Understanding Representations",
    "text": "Understanding Representations\nIf data contains characters like quotes and backslashes, R cannot directly represent them in a string. We can try to write each of these directly in a string and see what happens.\nQuotes:\n\n\"\"\"\n\nError: &lt;text&gt;:1:3: unexpected INCOMPLETE_STRING\n1: \"\"\"\n      ^\n\n\nR reads the first two set of quotes \"\" as an empty string, and considers the third set to be starting a second, incomplete string.\nBackslash:\n\n\"\\\"\n\nError: &lt;text&gt;:1:1: unexpected INCOMPLETE_STRING\n1: \"\\\"\n    ^\n\n\nThe backslash has a special behaviour, preventing the second \" from ending the string.\nSolution:\nSince R cannot represent quotes and backslash directly, it must instead represent them indirectly with special sequences of characters. For quotes, the representative sequence in R is \\\". For a backslash, the sequence is \\\\.\nWhen we place these sequences in strings, the output is not an error.\n\n\"\\\"\" \n\n[1] \"\\\"\"\n\n\n\n\"\\\\\"\n\n[1] \"\\\\\"\n\n\nFurther, we can see what each sequence represents by using the function writeLines:\n\n\"\\\"\" |&gt; writeLines()\n\n\"\n\n\n\n\"\\\\\" |&gt; writeLines()\n\n\\\n\n\nSequences \\\" and \\\\ start with a backslash because a backslash has a specific behaviour: it prevents the normal interpretation of the next character. The backslash in the string\"\\\"\" prevents the second quotes from being interpreted as the end of the string. As for the string \"\\\\\", because of the first backslash the second backslash is not normally interpreted as “preventing the normal interpretation of the next character”. Yes you will likely have to re-read that.\n\\\" and \\\\ are called special characters. Special characters are called special because they hold a special property: they each represent one thing (a unique character that cannot be represented directly). \\\" represents quotes, and \\\\ represents backslash. Scan the following list of special characters and what they represent.\n\n\n\nSpecial Characters\nRepresents\n\n\n\n\n\\n\nnewline\n\n\n\\r\ncarriage return\n\n\n\\t\ntab\n\n\n\\b\nbackspace\n\n\n\\a\nalert (bell)\n\n\n\\f\nform feed\n\n\n\\v\nvertical tab\n\n\n\\\\\nbackslash \\\n\n\n\\’\nASCII apostrophe ’\n\n\n\\”\nASCII quotation mark ”\n\n\n\\`\nASCII grave accent (backtick) `\n\n\n\nNotice how each has one backslash except for the case of \\\\. Again these special characters represent one thing. Representations of multiple things, however, have multiple backslashes (two to be exact). As an example, \\\\d represents multiple things because it represents any of the multiple digits from 0 to 9.\n\\\\ is a strange case. It is the only special character representing one thing with multiple backslashes. It is an even stranger case when used inside a pattern. We get an error:\n\npattern &lt;- \"\\\\\"\n\"\\\\\" |&gt; str_detect(\"\\\\\")\n\nError in stri_detect_regex(string, pattern, negate = negate, opts_regex = opts(pattern)): Unrecognized backslash escape sequence in pattern. (U_REGEX_BAD_ESCAPE_SEQUENCE, context=`\\`)\n\n\nAn error does not happen with any of the other special characters used in this way. The reason is that \\\\ is already used in patterns like \\\\d. If the pattern to match the string \"\\\\\" was simply \"\\\\\", representations like \\\\d would lose their meaning. For example, instead of matching digits, \\\\d would just match \\\\ followed by a d.\nTo match the string \"\\\\\" we must use the pattern \"\\\\\\\\\". To remember this, consider how R views four backslashes:\n\n\"\\\\\\\\\" |&gt; writeLines()\n\n\\\\"
  },
  {
    "objectID": "06-avoiding-repetition.html",
    "href": "06-avoiding-repetition.html",
    "title": "6  Avoiding Repetition",
    "section": "",
    "text": "Let’s say we need to read data in again, and we have named your files as per the chapter on File Naming. To summarize, the file names have phrases with words separated by -, and multiple phrases are separated by _.\nInstead of copy-pasting the same code we used the previous time, we can avoid this repetition with a function. We can create this function by assigning function() to an object, and entering the inputs inside the () like so:\n\nsum &lt;- function(x, y) x + y\nsum(2, 2)\n\n[1] 4\n\n\nThe inputs of a function should be the parts of the function that change over repeated use. Since we want to repeat the code to read in data, but without being repetitive, our function will only contain inputs that are not repetitive. What part of reading our data is not repetitive now that we want to repeat the task for a set of different files.\nFor one, we can imagine that a new set of files might have a different number of phrases in the file names. So one input of our function can be n_phrases. Two, we can imagine that the phrases represent something different. Since we named them previously, let us call a second input of our function names_phrases.\nLastly, we need to name our function. The function name should reflect the main behaviour. If it is hard to identify the main behaviour, then it is probably best to split the function into multiple functions. Naming the functions appropriately is important for readability.\nLet us start by listing the behaviours of our function or functions:\n\nChoose a file\nFind the folder (directory) of this file\nFind the names of the csv files in this folder\nGet a matrix from splitting the phrases in each name\nName the columns and turn the matrix into a tibble\nFor each row representing a file, read its respective data into the tibble\n\nThat is a lot for one name to represent. Hence it is more prudent to separate these behaviours into multiple functions.\nCONTINUE HERE\nAlthough we could place all the code needed to read in data inside our function and name the function read_csv_in_df, this is not a good idea. First, it is inconsistent with the popular function read_csv, which has more than two arguments, the first of which is a file path.\nWith only two arguments, our function has the form function(n_phrases, names_phrases){code}. The code it will execute is in curly brackets {}. Although curly brackets were not needed in function(x, y) x + y, it will be needed here as the code will have multiple lines.\nAlthough we could place all the code needed to read in data inside and name the function read_csv_in_df, then we would be acting without much care.\n\nread_csv_in_df &lt;- function(n_phrases, names_phrases){\n\n  one_file_path &lt;- file.choose()\n  directory_path &lt;- one_file_path |&gt; path_dir()\n  file_names &lt;- directory_path |&gt; list.files(pattern = \"csv\")\n  file_paths &lt;- directory_path |&gt; dir_ls()\n\n  split_matrix &lt;- file_names |&gt; str_split_fixed(\"[._]\", n_phrases)\n  colnames(split_matrix) &lt;- names_phrases\n\n  df &lt;- split_matrix |&gt;\n    as_tibble() |&gt;\n    mutate(data = map(file_paths, read_csv))\n\n  df\n\n}\n\n\n# read_csv_in_df\n\n\n# read_csv_in_df(4, c(\"source\", \"country\", \"date\" ,\"file_type\"))"
  },
  {
    "objectID": "10-next-steps.html",
    "href": "10-next-steps.html",
    "title": "8  Next Steps for This Guide",
    "section": "",
    "text": "How to make your work reproducible using “R projects”\nHow to mask or randomize data in order ot make it public\nHow to build your own website\nHow to build tables (gt) and plots (ggplot)"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "How to Be an Rtist: A Beginner’s Guide to Beautiful, Intentional R Projects",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#why-this-book",
    "href": "index.html#why-this-book",
    "title": "How to Be an Rtist: A Beginner’s Guide to Beautiful, Intentional R Projects",
    "section": "Why This Book?",
    "text": "Why This Book?\n\n\n\n\n\n\nI taught my spouse how to program in R (she had no previous knowledge despite completing a degree in Statistics). She, like many of us, was often frustrated while learning. I emphasized the kindness and generosity of the R community who write free books and provide support on forums. But as I started recommending books alongside our personal lessons, I noticed there wasn’t a book meant for a specific audience: a complete beginner wishing not only to turn their analysis into a report, but to do it in a way that avoids future frustration.\nSimply put, this book is meant for beginners who wish to immediately apply best practices to their own projects."
  },
  {
    "objectID": "index.html#for-the-love-of-r",
    "href": "index.html#for-the-love-of-r",
    "title": "How to Be an Rtist: A Beginner’s Guide to Beautiful, Intentional R Projects",
    "section": "For the Love of R",
    "text": "For the Love of R\nWithout a code- and project-oriented data science course, many beginner analysts know only mathematical or methodological knowledge and how to start a program. They are bound to write invalid code. The resulting invalid output is especially demotivating for analysts, as their task is to analyse the data. They may have been exposed to R in a Statistics courses, but these courses typically focus on methods and potentially mathematics; not work-flow, project-management, and coding. Furthermore, Statistics has a reputation for being hard, especially on those who are learning the subject only because it is required in a non-mathematical program.\nAs a result, R has two completely different reputations. Among students in Statistics courses, it is often despised. Among those who use the tool for work, it is usually loved. The difference may be caused by students paying to learn R, and employees being paid. But employees also realize, once they use R day-to-day, that there is an amazing community of others who help each other. This book is also meant to play a small part in that community."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "03-opening-data.html#checking-data",
    "href": "03-opening-data.html#checking-data",
    "title": "3  Opening Data",
    "section": "Checking Data",
    "text": "Checking Data\nThe simplest way to start evaluating data is to check that the values under each column meet expectations. Since we created the first 4 columns using our file names, we can be sure that these 4 columns are clean.\nFor the next column, continent, we expect values to be continents, capitalized, and spelled correctly. Instead of reading each line with our eyes, we can read each line with our computers. Or a combination of the two. That is exactly how we will start. We will check all unique (i.e. distinct) values under the continent column using distinct. It produces a tibble with only the distinct rows for the column(s) you choose.\n\ndistinct(df, continent)\n\n# A tibble: 2 × 1\n  continent\n  &lt;chr&gt;    \n1 Asia     \n2 Americas \n\n\nThese unique values are perfect. Which means every value is perfect, as these unique values represent them. But what if they were not capitalized, for example? That is in fact the case with our country column: the values are not capitalized because the values came from our file-naming, and it is good practice not to capitalize when file-naming. To capitalize the values in a column, you can use a function called str_to_title.\n\nstr_to_title(df$country)\n\n [1] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\"\n [6] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\"\n[11] \"Afghanistan\" \"Afghanistan\" \"Canada\"      \"Canada\"      \"Canada\"     \n[16] \"Canada\"      \"Canada\"      \"Canada\"      \"Canada\"      \"Canada\"     \n[21] \"Canada\"      \"Canada\"      \"Canada\"      \"Canada\"     \n\ndf\n\n# A tibble: 24 × 9\n   source    country     date  file_type continent year  lifeExp pop   gdpPercap\n   &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    \n 1 gapminder afghanistan 2022… csv       Asia      1952  28.801  8425… 779.4453…\n 2 gapminder afghanistan 2022… csv       Asia      1957  30.332  9240… 820.8530…\n 3 gapminder afghanistan 2022… csv       Asia      1962  31.997  1026… 853.10071\n 4 gapminder afghanistan 2022… csv       Asia      1967  34.02   1153… 836.1971…\n 5 gapminder afghanistan 2022… csv       Asia      1972  36.088  1307… 739.9811…\n 6 gapminder afghanistan 2022… csv       Asia      1977  38.438  1488… 786.11336\n 7 gapminder afghanistan 2022… csv       Asia      1982  39.854  1288… 978.0114…\n 8 gapminder afghanistan 2022… csv       Asia      1987  40.822  1386… 852.3959…\n 9 gapminder afghanistan 2022… csv       Asia      1992  41.674  1631… 649.3413…\n10 gapminder afghanistan 2022… csv       Asia      1997  41.763  2222… 635.3413…\n# ℹ 14 more rows"
  },
  {
    "objectID": "03-opening-data.html#finding-functions",
    "href": "03-opening-data.html#finding-functions",
    "title": "3  Opening Data",
    "section": "Finding Functions",
    "text": "Finding Functions\nHow would you know which function to use if I did not tell you?\n\nLarge-Language-Models\nNo explanation needed.\n\n\nGoogle\nGoogle is a great search engine that most R programmers use when learning the R language. If we search “r capitalize first letter” we see, on 2025-01-10, the following paragraph as the first result:\n\nConvert First letter of every word to Uppercase in R Programming – str_to_title() Function. str_to_title() Function in R Language is used to convert the first letter of every word of a string to Uppercase and the rest of the letters are converted to lower case.\n\nThe trick is to, within Google, always write r before a question or the desired command, like how to capitalize first letter or simply capitalize first letter.\nThis is a simple example. Most of the time it can be difficult to write in English what you want. This will come with time and practice. At first you may find that the Google search results have nothing to do with what you need. That is a sign to re-word your search, or, if you’ve already re-worded your search, it may be a sign that there is no dedicated function for what you need, or that a different approach is needed. It’s rare that there will be no dedicated function so long as your goal is simple. You may find that it is effective to break down what you’re doing into simple steps, and then search for how to do those steps, as opposed to Googling something long and complicated, involving many steps.\n\n\nStack Overflow\nSpeaking of breaking down something complicated so that a search engine like Google can understand it, this is also necessary for others to understand it. For learning R, allowing others to understand your challenge or need is valuable as the R community is not only willing, but also quickly able to help. R users mainly help each other through Stack Overflow. It is a website that easily allows users to ask or answer questions with code, have their code formatted (look nice), and receive feedback.\nThe main draw of Stack Overflow is that the person asking the question has one main responsibility, and that is to produce what is called a minimally reproducible example: an example that can be used (reproduced) by someone else seeing the question, and that does not have unnecessary detail irrelevant to the question (minimal).\nDescribe example\nEXAMPLE HERE\nKnowing how to make an example is the majority of the work involved in asking a question on Stack Overflow.\n\nCreating Minimally Reproducible Examples\nIf your question involves data frames, you need to learn how to build a data frame before asking your question on Stack Overflow. To build a data frame, you can use the tibble function from package tibble.\nIf you have 2 numeric columns, like in\n\n\n# A tibble: 12 × 2\n   year  lifeExp\n   &lt;chr&gt; &lt;chr&gt;  \n 1 1952  28.801 \n 2 1957  30.332 \n 3 1962  31.997 \n 4 1967  34.02  \n 5 1972  36.088 \n 6 1977  38.438 \n 7 1952  68.75  \n 8 1957  69.96  \n 9 1962  71.3   \n10 1967  72.13  \n11 1972  72.88  \n12 1977  74.21  \n\n\nthen the first part of your minimal example might look this:\n\ntibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\n\n# A tibble: 4 × 2\n      x     y\n  &lt;dbl&gt; &lt;dbl&gt;\n1     1     3\n2     2     4\n3     1     2\n4     2     2\n\n\nAnd if what you’re trying to achieve is\n\n\n# A tibble: 6 × 2\n  year  mean_lifeExp\n  &lt;chr&gt;        &lt;dbl&gt;\n1 1952          48.8\n2 1957          50.1\n3 1962          51.6\n4 1967          53.1\n5 1972          54.5\n6 1977          56.3\n\n\nthen the second part of your minimal example might look like this:\n\ntibble(x = c(1, 2), mean_y = c(2.5, 2))\n\n# A tibble: 2 × 2\n      x mean_y\n  &lt;dbl&gt;  &lt;dbl&gt;\n1     1    2.5\n2     2    2  \n\n\nTo summarize, your entire question on Stack Overflow could look like this:\nHow can I transform the first tibble into the second tibble with a function?\nlibrary(tibble)\ntibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\ntibble(x = c(1, 2), mean_y = c(2.5, 2))\nTo make your question even better, you can format your code by using the reprex function from the reprex package. The curly brackets are needed to tell reprex that you have multiple lines of code.\n\nlibrary(reprex)\nreprex(\n  {\n    library(tibble)\n    tibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\n    tibble(x = c(1, 2), mean_y = c(2.5, 2))\n  }\n)\n\nFinally your question looks friendly:\nHow can I transform the first tibble into the second tibble with a function?\n\nlibrary(tibble)\ntibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2))\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3\n#&gt; 2     2     4\n#&gt; 3     1     2\n#&gt; 4     2     2\ntibble(x = c(1, 2), mean_y = c(2.5, 2))\n#&gt; # A tibble: 2 × 2\n#&gt;       x mean_y\n#&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1     1    2.5\n#&gt; 2     2    2"
  },
  {
    "objectID": "03-opening-data.html#finding-function-documentation-for-understanding-functions",
    "href": "03-opening-data.html#finding-function-documentation-for-understanding-functions",
    "title": "3  Opening Data",
    "section": "Finding Function Documentation for Understanding Functions",
    "text": "Finding Function Documentation for Understanding Functions\nOnce you’ve found a function (or usually, a set of functions) recommended to you by Google’s search results, or by R users on Stack Overflow, it would be wise to understand how the function(s) work; specifically, the inputs and outputs.\nBoth Google and Stack Overflow can be overwhelming. Google gives a variety of websites. Which do you choose? A question on Stack Overflow can receive multiple answers, with each using different approaches and functions. Again, which do you choose?\nLet’s start with Google then.\n\nGoogle\nRemember, after searching “r capitalize first letter” we saw the following paragraph as the first result:\n\nConvert First letter of every word to Uppercase in R Programming – str_to_title() Function. str_to_title() Function in R Language is used to convert the first letter of every word of a string to Uppercase and the rest of the letters are converted to lower case.\n\nThis paragraph is from a website called GeeksforGeeks\nI would not recommend to use this website. That is, after searching “r capitalize first letter” and seeing the the above paragraph, I would not recommend to visit the website to understand the function. And for multiple reasons.\n\nYou are not familiar with the format of the website.\nYou will find yourself on multiple websites when you need to discover and learn about multiple functions.\nYou will then have to navigate the formats of these websites.\nMany things can get in the way of reading the instructions, like pop-ups to sign up for the website’s email list, advertisements for completely unrelated products (everything you need to learn R is FREE), and recommended articles to distract you.\n\nIt is more effective to use a single, standardized resource when learning about functions. Thankfully, R has a few.\nAfter reading the above paragraph and learning that the function we need may be str_to_title(), we can now Google search “r str_to_title” instead of “r capitalize first letter”. Again, Google shows multiple websites, but we are looking for one that is standardized. tidyverse.org is one of those websites, so we click the result that has “tidyverse.org” in the website address This brings us to this page: https://stringr.tidyverse.org/reference/case.html\nAs standard, there are multiple sections to the webpage describing a function: Usage, Arguments and Examples. Usage shows the format of the inputs to the function. Any input with an = beside it has a default value. A default value usually indicates that most users will not need to change the value.\nThe Usage str_to_title(string, locale = \"en\") tells us that\n\nstring should be an object containing some string(s) or a string itself. It has no default value; we must provide one.\nlocale has the default value \"en\".\n\nThe Arguments tell us more about the inputs in case the Usage is not enough. When first learning R, Arguments can be overwhelming; you might quickly find yourself not understanding the words contained therein, and having to continuously look up definitions (or more function documentation) in order to understand.\n\n\nStack Overflow\nAnother way of understanding functions is to be presented with answers from others on Stack Overflow. These answers don’t need to be answers to the questions you have posted on Stack Overflow; they can be answers to questions posted by others.\nFor example, here is a question dated from 2019: https://stackoverflow.com/questions/58996293/transforming-a-dataframe-by-multiplying-a-columns-elements-by-the-names-of-th\nThere are three separate answers that have up votes (positive feedback represented by the digit on the top left of an answer): 1 using the data.table package; 1 using base R (R without packages); and 1 using tidyr.\nNotice how the answer using tidyr is far more simple; it is one line of code. This word tidy keeps popping up, and for good reason: the functions in this package and more broadly in the tidyverse (the tidy universe) are designed to make coding short and simple.\nIt is possible to add comments to the answers on Stack Overflow, with further questions about the functions if there is something you don’t understand. Fortunately the tidyverse functions are well documented because of their standardized webpages, and because of multiple, free books on using them for specific tasks.\n\n\nBooks\nThere are many books describing tidyverse functions. Finding a good book is a strong alternative to using Google or Stack Overflow toward understanding functions. A book can hold your hand throughout each step and provide a narrative. It can also be designed toward a specific task, just as this one is designed toward getting you started as quickly and comfortably as possible."
  }
]